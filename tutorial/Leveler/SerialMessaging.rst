******************
Serial Messaging
******************

.. contents:: Contents
    :local:
    
.. sectionauthor:: Joseph S Motyka <jmotyka at aceinna.com>


Serial Message Definition
==========================

A streaming, serial message can be generated by the OpenIMU platform. In this example, a message
matching the requirements, defined earlier, is created.  It consists of:

    1. An integer counter, representing time in :math:`[ms]`
    2. A floating point representation of time, in :math:`[s]`
    3. Roll and pitch angles, in [°]
    4. Acceleration readings, in :math:`[m/s^2]`


To generate this output, a serial-message was created in *UserMessaging.c* and *UserMessaging.h*.
In the firmware, the message is given the name, *USR_OUT_LEV1*, along with the packet code “l1”
(with lower-case L representing leveler).


To form the message, the first step is to define the message components and determine the total
number of bytes the message will occupy.  The components of the message, variable type, and number
of bytes are listed in the following table:


.. table:: **User-Defined Serial Message Components**

    +-----------------------+----------------------+----------------+------------+
    |                       | **Description**      |                |            |
    | **Message Component** |                      || **Number of** || **Total** |
    |                       +----------+-----------+| **Variables** || **Bytes** |
    |                       |          |           |                |            |
    |                       | **Type** | **Bytes** |                |            |
    |                       |          |           |                |            |
    +=======================+==========+===========+================+============+
    |                       |          |           |                |            |
    | Integer counter       | uint32_t | 4         | 1              | 4          |        
    |                       |          |           |                |            |
    +-----------------------+----------+-----------+----------------+------------+
    |                       |          |           |                |            |
    | Time variable         | Double   | 8         | 1              | 8          |                             
    |                       |          |           |                |            |
    +-----------------------+----------+-----------+----------------+------------+
    |                       |          |           |                |            |
    || Attitude measurement | Float    | 4         | 2              | 8          |               
    || (roll/pitch)         |          |           |                |            |
    |                       |          |           |                |            |
    +-----------------------+----------+-----------+----------------+------------+
    |                       |          |           |                |            |
    || Acceleration         | Float    | 4         | 3              | 12         |               
    || (3 axis)             |          |           |                |            |
    |                       |          |           |                |            |
    +-----------------------+----------+-----------+----------------+------------+


This shows that the *payload* section of the output message (not including preamble, message
type, or CRC) consists of 32 bytes.


Adding this message to the firmware requires modifications to two files: *UserMessaging.c* and
*UserMessaging.h*.


*UserMessaging.h* Modifications
================================

The packet code and number of bytes must be added to UserMessaging.h. This requires adding the
output packet code to the packet-type enum variable:

::

    // User output packet codes, change at will
    typedef enum {
        USR_OUT_NONE = 0, // 0
        USR_OUT_TEST,     // 1
        USR_OUT_DATA1,    // 2
        // add new output packet type here, before USR_OUT_MAX
        USR_OUT_LEV1,     // 3
        USR_OUT_MAX
    } UserOutPacketType;


and creating a *#define* identifier to hold the payload length

::

    #define USR_OUT_LEV1_PAYLOAD_LEN (32)

    
These can be found in the Static-Leveler example code.


*UserMessaging.c* Modifications
================================

With the above additions to *UserMessaging.h* made, the output message can be added to
*UserMessaging.c*, completing the process.  To accomplish this, add a new case to the
switch-statement found in *HandleUserOutputPacket()* using the output name added to
*UserMessaging.h*:

::

    case USR_OUT_LEV1:
    {
        // Variables used to hold the EKF values
        real EulerAngles[3];
        double accels[3];
        
        // The payload length (NumOfBytes) is based on the following:
        // 1 uint32_t (4 bytes) = 4 bytes
        // 1 double (8 bytes) = 8 bytes
        // 2 floats (4 bytes) = 8 bytes
        // 3 floats (4 bytes) = 12 bytes
        // =================================
        // NumOfBytes = 32 bytes
        *payloadLen = USR_OUT_LEV1_PAYLOAD_LEN;
        
        // Output time as represented by gLeveler.timerCntr (uint32_t
        // incremented at each call of the algorithm)
        uint32_t *algoData_1 = (uint32_t*)(payload);
        *algoData_1++ = gLeveler.timerCntr;
        
        // Output a double representation of time generated from
        // gLeveler.timerCntr
        double *algoData_2 = (double*)(algoData_1);
        *algoData_2++ = 1.0e-3 * (double)(gLeveler.timerCntr);
        
        // Set the pointer of the algoData array to the payload
        float *algoData_3 = (float*)(algoData_2);
        Leveler_GetAttitude_EA(EulerAngles);
        *algoData_3++ = (float)EulerAngles[ROLL];
        *algoData_3++ = (float)EulerAngles[PITCH];
        
        GetAccelsData_mPerSecSq(accels);
        *algoData_3++ = (float)accels[X_AXIS];
        *algoData_3++ = (float)accels[Y_AXIS];
        *algoData_3++ = (float)accels[Z_AXIS];
    }
    break;


Data is appended to the payload array using pointers.  This enables variables of different
datatypes to fit into the payload array (defined as an array of 8-bit unsigned integers); this
approach is highlighted in the previous code snippet and is done by generating a pointer of the
desired type to a typecast version of the payload address.  In the example above, 32-bit unsigned
integer data is appended to the payload, followed by double and floating-point variables.


Finally, the packet type must be added to the switch-statement in *setUserPacketType()* to enable
the firmware to select the packet:

::

    case USR_OUT_LEV1: // packet with leveler algorithm data
        _outputPacketType = type;
        _userPayloadLen = USR_OUT_LEV1_PAYLOAD_LEN;
        break;
    
    
and the packet-code must be added to the list of user output packets, *userOutputPackets*.

::

    // packet codes here should be unique -
    // should not overlap codes for input packets and system packets
    // First byte of Packet code should have value >= 0x61
    usr_packet_t userOutputPackets[] = {
        // Packet Type Packet Code
        {USR_OUT_NONE, {0x00, 0x00}},
        {USR_OUT_TEST,  "zT"},
        {USR_OUT_DATA1, "z1"},
        // place new type and code here
        {USR_OUT_LEV1,  "l1"},
        {USR_OUT_MAX, {0xff, 0xff}}, // ""
    };


These changes are found in *UserMessaging.c*.


Default Configuration Settings
===============================

To make the "l1" serial message (created previously) the default output, make changes to the
default user-configuration structure found in *UserConfiguration.c*:

::

    // Default user configuration structure
    // Applied to unit upon reception of "zR" command
    // Do Not remove - just add extra parameters if needed
    // Change default settings if desired
    const UserConfigurationStruct gDefaultUserConfig = {
        .dataCRC = 0,
        .dataSize = sizeof(UserConfigurationStruct),
        .userUartBaudRate = 115200,
        .userPacketType = "l1",
        .userPacketRate = 5,
        .lpfAccelFilterFreq = 50,
        .lpfRateFilterFreq = 50,
        .orientation = "+X+Y+Z"
        // add default parameter values here, if desired
    } ;


.. note::

    *userPacketType* was set to “l1” to cause the new packet to be broadcast by default.
    Additionally, the desired message baud rate and message rate are set to 115.2 kbps and 5
    [Hz], respectively.  Finally, the accelerometer and rate-sensor filters are set to 50 Hz.


Testing using Serial Terminal Emulator
=======================================

At this point, the Static-Leveler application has been implemented and the output messaging
created.  Build and upload the firmware to the OpenIMU.  A serial terminal (such as TeraTerm) can
be used to verify if a message is being generated by the device.  In the following figure, output
messaging creation can be verified by searching for the string “UUl1”.  If present, the message is
being generated; whether the message is populated correctly requires the use of additional tools.

.. _fig-ser-msg-test:

.. figure:: ./media/Leveler_OutputMessageCapture.PNG
    :alt: SerialMessageTest
    :width: 5.1in
    :align: center

    **Test of Serial Message Output**


.. note::

    In the above figure the message preamble sometimes displays as :math:`"UU \ulcorner 1"`.  This is solely a
    TeraTerm glitch.  Other serial terminal programs (such as CoolTerm) do not show such
    behavior.

